# -*- coding: utf-8 -*-

System Diagram Data Aggregator

This module provides data aggregation for the interactive flowchart view showing:
    pass
the complete Records Management System architecture, relationships, and access controls.

Key Features
- Model relationship mapping
- User access visualization (red/green indicators)
- Company and department assignments
- Portal vs backend access differentiation
- Real-time permission checking
- Interactive search and filtering

Business Value
- System architecture visualization
- Access control auditing
- User training and onboarding
- Compliance documentation
- System administration overview

Author: Records Management System
Version: 18.0.6.0.0
License: LGPL-3


import json
import logging

from odoo import models, fields, api



_logger = logging.getLogger(__name__)


class SystemDiagramData(models.TransientModel):
    _name = "system.diagram.data"
    _description = "System Architecture Diagram Data Aggregator"

        # ============================================================================
    # MODEL CACHE PROPERTY
        # ============================================================================
    @property
    def _model_exists_cache(self):
        """Access model existence cache through registry"""
        if not hasattr(self.env.registry, "_model_cache"):
            self.env.registry._model_cache = {}
        return self.env.registry._model_cache

    # ============================================================================
        # CORE FIELDS
    # ============================================================================
    name = fields.Char(
        string="Diagram Name",
        default="Records Management System Architecture",
        required=True,
    
    search_query = fields.Char(
        string="Search Query",
        help="Search for users, companies, or models",:
    
    search_type = fields.Selection(
        []
            ("user", "User Search"),
            ("company", "Company Search"),
            ("model", "Model Search"),
            ("access", "Access Rights"),
        
        string="Search Type",
        default="user",
    
    show_access_only = fields.Boolean(
        string="Show Access Only",
        default=False,
        help="Show only access-related connections",
    
    
        # ============================================================================
    # FRAMEWORK FIELDS FOR MAIL THREAD COMPATIBILITY
        # ============================================================================
    activity_ids = fields.One2many(
        'mail.activity',
        'res_id',
        string='Activities',
        domain=lambda self: [('res_model', '=', self._name)],
        auto_join=True,
    
    message_follower_ids = fields.One2many(
        'mail.followers', 
        'res_id', 
        string='Followers',
        domain=lambda self: [('res_model', '=', self._name)],
        help="List of partners following the record.",
    
    message_ids = fields.One2many(
        'mail.message',
        'res_id',
        string='Messages',
        domain=lambda self: [('res_model', '=', self._name)],
        auto_join=True,
    
    
    generation_time = fields.Float(string="Generation Time (seconds)", digits=(6,2))
    node_spacing = fields.Integer(string="Node Spacing", default=100),
    edge_length = fields.Integer(string="Edge Length", default=150),
    layout_algorithm = fields.Selection([("hierarchical", "Hierarchical"), ("spring", "Spring"]), ("circular", "Circular")], string="Layout Algorithm")
    include_inactive = fields.Boolean(string="Include Inactive", default=False),
    group_by_module = fields.Boolean(string="Group By Module", default=True),
    max_depth = fields.Integer(string="Maximum Depth", default=3),
    exclude_system_models = fields.Boolean(string="Exclude System Models", default=True),
    last_access = fields.Datetime(string="Last Access")
        # ============================================================================
    # BUSINESS DIAGRAM FIELDS
        # ============================================================================
    diagram_html = fields.Html(
        string='Diagram HTML',
        readonly=True,
        help="Generated HTML for the interactive diagram",:
    
    cache_timestamp = fields.Datetime(
        string='Cache Timestamp',
        readonly=True,
        help="Last time the diagram data was cached",
    
    cache_size = fields.Integer(
        string='Cache Size',
        readonly=True,
        help="Size of cached diagram data in bytes",
    
    edge_count = fields.Integer(
        string='Edge Count',
        readonly=True,
        help="Number of relationships in the diagram",
    
    node_count = fields.Integer(
        string='Node Count', 
        readonly=True,
        help="Number of entities in the diagram",
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        default=lambda self: self.env.company,
        help="Company scope for diagram data",:
    

        # ============================================================================
    # DIAGRAM DATA FIELDS
        # ============================================================================
    nodes_data = fields.Text(
        string="Nodes Data",
        compute="_compute_diagram_data",
        store=False,
        help="JSON data for diagram nodes",:
    
    edges_data = fields.Text(
        string="Edges Data",
        compute="_compute_diagram_data",
        store=False,
        help="JSON data for diagram edges",:
    
    diagram_config = fields.Text(
        string="Diagram Configuration", 
        compute="_compute_diagram_config",
        store=False,
        help="Configuration options for the diagram",:
    

        # ============================================================================
    # COMPUTE METHODS
        # ============================================================================
    @api.depends("search_query", "search_type", "show_access_only")
    def _compute_diagram_data(self):
        """Generate nodes and edges data for the diagram""":
        for record in self:
            try:
                nodes = []
                edges = []

                # Core system nodes
                core_nodes = record._get_core_system_nodes()
                nodes.extend(core_nodes)

                # Model relationship nodes
                if not record.show_access_only:
                    model_nodes, model_edges = record._get_model_relationships()
                    nodes.extend(model_nodes)
                    edges.extend(model_edges)

                # User and access nodes
                user_nodes, access_edges = record._get_user_access_data()
                nodes.extend(user_nodes)
                edges.extend(access_edges)

                # Company and department nodes
                company_nodes, company_edges = record._get_company_structure()
                nodes.extend(company_nodes)
                edges.extend(company_edges)

                # Apply search filters
                if record.search_query:
                    nodes, edges = record._apply_search_filter(nodes, edges)

                record.nodes_data = json.dumps(nodes)
                record.edges_data = json.dumps(edges)

            except Exception as e
                _logger.error("Error computing diagram data: %s", str(e))
                record.nodes_data = json.dumps([
                record.edges_data = json.dumps([

    @api.depends("search_type")
    def _compute_diagram_config(self):
        """Generate diagram configuration"""
        for record in self:
            config = {}
                "layout": {}
                    "hierarchical": {}
                        "enabled": True,
                        "direction": "UD",
                        "sortMethod": "directed",
                        "levelSeparation": 150,
                        "nodeSpacing": 200,
                    
                
                "physics": {}
                    "enabled": True,
                    "stabilization": {"iterations": 100},
                
                "interaction": {}
                    "hover": True,
                    "multiselect": True,
                    "selectConnectedEdges": False,
                
                "nodes": {}
                    "font": {"size": 14, "color": "#000000"},
                    "borderWidth": 2,
                    "shadow": True,
                
                "edges": {}
                    "arrows": {"to": {"enabled": True, "scaleFactor": 0.5}},
                    "font": {"size": 12},
                    "smooth": {"type": "dynamic"},
                
            
            record.diagram_config = json.dumps(config)

    # ============================================================================
        # DATA GENERATION METHODS
    # ============================================================================
    def _get_core_system_nodes(self):
        """Get core system component nodes"""
        nodes = []
            {}
                "id": "core_system",
                "label": "Records Management\nSystem",
                "group": "system",
                "color": {"background": "#2E86AB", "border": "#1B4B73"},
                "shape": "box",
                "font": {"color": "white", "size": 16},
                "level": 0,
            
            {}
                "id": "backend",
                "label": "Backend\n(Internal Users)",
                "group": "interface",
                "color": {"background": "#A23B72", "border": "#6B1E47"},
                "shape": "ellipse",
                "level": 1,
            
            {}
                "id": "portal",
                "label": "Customer Portal\n(External Users)",
                "group": "interface",
                "color": {"background": "#F18F01", "border": "#B8630F"},
                "shape": "ellipse",
                "level": 1,
            
            {}
                "id": "naid_compliance",
                "label": "NAID AAA\nCompliance",
                "group": "compliance",
                "color": {"background": "#C73E1D", "border": "#8B2817"},
                "shape": "diamond",
                "level": 2,
            
        
        return nodes

    def _get_model_relationships(self):
        """Get Records Management model relationships"""
        nodes = []
        edges = []

        # Core Records Management models
        core_models = []
            ("records.container", "Container", "#4CAF50"),
            ("records.document", "Document", "#2196F3"),
            ("records.location", "Location", "#FF9800"),
            ("pickup.request", "Pickup Request", "#9C27B0"),
            ("shredding.service", "Shredding Service", "#F44336"),
            ("portal.request", "Portal Request", "#607D8B"),
            ("customer.feedback", "Customer Feedback", "#795548"),
            ("naid.compliance", "NAID Compliance", "#E91E63"),
        

        # Add model nodes
        for model_name, display_name, color in core_models:
            if self._model_exists(model_name):
                node_id = f"model_{model_name.replace('.', '_')}"
                nodes.append()
                    {}
                        "id": node_id,
                        "label": display_name,
                        "group": "model",
                        "color": {}
                            "background": color,
                            "border": self._darken_color(color),
                        
                        "shape": "box",
                        "level": 3,
                    
                

                # Add edge to core system
                edges.append()
                    {}
                        "from": "core_system",
                        "to": node_id,
                        "color": {"color": "#666666"},
                        "arrows": {"to": {"enabled": True}},
                    
                

        # Add relationship edges between models
        relationships = self._get_model_field_relationships()
        edges.extend(relationships)

        return nodes, edges

    def _get_user_access_data(self):
        """Get user access rights visualization"""
        nodes = []
        edges = []

        try:
            # Get Records Management groups
            groups = self.env["res.groups"].search()
                []
                    ("name", "ilike", "records"),
                    ("name", "ilike", "shredding"),
                    ("name", "ilike", "warehouse"),
                
            

            # Add group nodes
            for group in groups:
                group_id = f"group_{group.id}"
                nodes.append()
                    {}
                        "id": group_id,
                        "label": group.name,
                        "group": "security_group",
                        "color": {"background": "#8BC34A", "border": "#4CAF50"},
                        "shape": "ellipse",
                        "level": 4,
                    
                

                # Connect to backend
                edges.append()
                    {}
                        "from": "backend",
                        "to": group_id,
                        "color": {"color": "#4CAF50"},
                        "arrows": {"to": {"enabled": True}},
                        "label": "Access",
                    
                

            # Get users (limit for performance):
            users = self.env["res.users"].search()
                []
                    ("active", "=", True),
                    ("share", "=", False),  # Internal users only
                
                limit=20,
            

            for user in users:
                user_id = f"user_{user.id}"

                # Check if user has Records Management access:
                has_access = self._check_user_records_access(user)
                user_color = "#4CAF50" if has_access else "#F44336":
                nodes.append()
                    {}
                        "id": user_id,
                        "label": user.name,
                        "group": "user",
                        "color": {}
                            "background": user_color,
                            "border": self._darken_color(user_color),
                        
                        "shape": "circle",
                        "level": 5,
                    
                

                # Connect user to their groups
                for group in user.groups_id:
                    if group.id in [g.id for g in groups]:
                        edges.append()
                            {}
                                "from": user_id,
                                "to": f"group_{group.id}",
                                "color": {"color": user_color},
                                "arrows": {"to": {"enabled": True}},
                                "label": "Member",
                            
                        

            # Portal users
            portal_users = self.env["res.users"].search()
                []
                    ("active", "=", True),
                    ("share", "=", True),  # Portal users
                
                limit=10,
            

            for user in portal_users:
                user_id = f"portal_user_{user.id}"
                nodes.append()
                    {}
                        "id": user_id,
                        "label": f"{user.name}\n(Portal)",
                        "group": "portal_user",
                        "color": {"background": "#FF9800", "border": "#F57C00"},
                        "shape": "circle",
                        "level": 5,
                    
                

                # Connect to portal
                edges.append()
                    {}
                        "from": user_id,
                        "to": "portal",
                        "color": {"color": "#FF9800"},
                        "arrows": {"to": {"enabled": True}},
                        "label": "Access",
                    
                

        except Exception as e
            _logger.warning("Error getting user access data: %s", str(e))

        return nodes, edges

    def _get_company_structure(self):
        """Get company and department structure"""
        nodes = []
        edges = []

        try:
            # Companies
            companies = self.env["res.company"].search([
            for company in companies:
                company_id = f"company_{company.id}"
                nodes.append()
                    {}
                        "id": company_id,
                        "label": company.name,
                        "group": "company",
                        "color": {"background": "#3F51B5", "border": "#1A237E"},
                        "shape": "box",
                        "level": 6,
                    
                

                # Connect to core system
                edges.append()
                    {}
                        "from": "core_system",
                        "to": company_id,
                        "color": {"color": "#3F51B5"},
                        "arrows": {"to": {"enabled": True}},
                        "label": "Company",
                    
                

            # Departments (if records.department exists):
            if self._model_exists("records.department"):
                departments = self.env["records.department"].search([
                for dept in departments:
                    dept_id = f"department_{dept.id}"
                    nodes.append()
                        {}
                            "id": dept_id,
                            "label": dept.name,
                            "group": "department",
                            "color": {"background": "#673AB7", "border": "#4527A0"},
                            "shape": "ellipse",
                            "level": 7,
                        
                    

                    # Connect to company
                    if hasattr(dept, "company_id") and dept.company_id:
                        edges.append()
                            {}
                                "from": f"company_{dept.company_id.id}",
                                "to": dept_id,
                                "color": {"color": "#673AB7"},
                                "arrows": {"to": {"enabled": True}},
                                "label": "Department",
                            
                        

        except Exception as e
            _logger.warning("Error getting company structure: %s", str(e))

        return nodes, edges

    def _get_model_field_relationships(self):
        """Get relationships between models based on fields"""
        edges = []

        try:
            # Define key relationships to visualize
            key_relationships = []
                ("records.container", "records.document", "Documents"),
                ("records.document", "records.location", "Location"),
                ("pickup.request", "records.container", "Containers"),
                ("shredding.service", "records.container", "Shred Items"),
                ("portal.request", "res.partner", "Customer"),
                ("naid.compliance", "records.document", "Compliance"),
            

            for from_model, to_model, label in key_relationships:
                if self._model_exists(from_model) and self._model_exists(to_model):
                    from_id = f"model_{from_model.replace('.', '_')}"
                    to_id = f"model_{to_model.replace('.', '_')}"

                    edges.append()
                        {}
                            "from": from_id,
                            "to": to_id,
                            "color": {"color": "#999999"},
                            "arrows": {"to": {"enabled": True}},
                            "label": label,
                            "dashes": True,
                        
                    

        except Exception as e
            _logger.warning("Error getting model relationships: %s", str(e))

        return edges

    # ============================================================================
        # UTILITY METHODS
    # ============================================================================
    def _model_exists(self, model_name):
        """Check if a model exists in the system, with caching for performance""":
        if model_name in self._model_exists_cache:
            return self._model_exists_cache[model_name]
        try:
            exists = model_name in self.env
            self._model_exists_cache[model_name] = exists
            return exists
        except (AttributeError, KeyError, TypeError)
            self._model_exists_cache[model_name] = False
            return False

    def _check_user_records_access(self, user):
        """Check if user has access to Records Management""":
        try:
            # Check if user has any records management groups:
            records_groups = self.env["res.groups"].search()
                []
                    ("name", "ilike", "records"),
                
            

            for group in records_groups:
                if group in user.groups_id:
                    return True

            # Check access to key model
            return user.has_group("records_management.group_records_user")
        except (AttributeError, KeyError, TypeError)
            return False

    def _apply_search_filter(self, nodes, edges):
        """Apply search filtering to nodes and edges"""
        if not self.search_query:
            return nodes, edges

        query = self.search_query.lower()
        filtered_nodes = []
        filtered_edges = []

        # Filter nodes based on search query
        for node in nodes:
            label_lower = node.get("label", "").lower()
            if query in label_lower:
                filtered_nodes.append(node)

        # Keep only edges connecting filtered nodes
        filtered_node_ids = [node["id"] for node in filtered_nodes]:
        for edge in edges:
            if edge["from"] in filtered_node_ids or edge["to"] in filtered_node_ids:
                filtered_edges.append(edge)

        return filtered_nodes, filtered_edges

    def _darken_color(self, hex_color):
        """Darken a hex color for borders""":
        try:
            # Simple darkening by reducing RGB values
            hex_color = hex_color.lstrip("#")
            rgb = tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4)):
            darkened = tuple(max(0, int(c * 0.7)) for c in rgb):
            return "#%02x%02x%02x" % darkened
        except (ValueError, IndexError, TypeError)
            return "#333333"

    # ============================================================================
        # ACTION METHODS
    # ============================================================================
    def action_refresh_diagram(self):
        """Refresh the diagram data"""

        self.ensure_one()
        self._compute_diagram_data()
        self._compute_diagram_config()

        return {}
            "type": "ir.actions.client",
            "tag": "reload",
        

    def action_export_diagram_data(self):
        """Export diagram data for external use""":
        self.ensure_one()

        export_data = {}
            "diagram_name": self.name,
            "nodes": json.loads(self.nodes_data or "[]"),
            "edges": json.loads(self.edges_data or "[]"),
            "config": json.loads(self.diagram_config or "{}"),
            "timestamp": fields.Datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
        

        import base64

        json_data = json.dumps(export_data)
        b64_data = base64.b64encode(json_data.encode("utf-8")).decode("utf-8")
        return {}
            "type": "ir.actions.act_url",
            "url": f"data:application/json;base64,{b64_data}",
            "target": "self",
        
