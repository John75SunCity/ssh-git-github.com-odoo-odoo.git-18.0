# -*- coding: utf-8 -*-

from odoo import api, fields, models, _
from odoo.exceptions import UserError, ValidationError
import re


class BinBarcodeInventory(models.Model):
    _name = 'bin.barcode.inventory'
    _description = 'Bin Barcode and Inventory Management'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'barcode desc'

    # Core Fields
    name = fields.Char(
        string='Bin Name',
        compute='_compute_name',
        store=True,
        readonly=True
    )
    barcode = fields.Char(
        string='Barcode',
        required=True,
        tracking=True,
        index=True,
        help="10-digit barcode for bin identification"
    )
    bin_size = fields.Selection([
        ('23_gallon', '23 Gallon'),
        ('32_gallon', '32 Gallon'),
        ('32_console', '32 Gallon Console'),
        ('64_gallon', '64 Gallon'),
        ('96_gallon', '96 Gallon'),
    ], string='Bin Size', required=True, tracking=True)

    bin_type = fields.Selection([
        ('bin', 'Regular Bin'),
        ('console', 'Console'),
    ], string='Bin Type', compute='_compute_bin_type', store=True)

    # Status and Location
    state = fields.Selection([
        ('available', 'Available'),
        ('in_use', 'In Use'),
        ('full', 'Full'),
        ('maintenance', 'Maintenance'),
        ('retired', 'Retired'),
    ], string='Status', default='available', tracking=True)

    location = fields.Char(
        string='Current Location',
        tracking=True,
        help="Physical location of the bin"
    )

    # Import and Generation Flags
    is_imported = fields.Boolean(
        string='Imported Bin',
        default=False,
        help="True if bin was imported from existing system"
    )
    is_generated = fields.Boolean(
        string='Generated Barcode',
        default=False,
        help="True if barcode was auto-generated by sequence"
    )

    # Audit and Notes
    notes = fields.Text(string='Notes')
    active = fields.Boolean(default=True)

    @api.depends('barcode', 'bin_size')
    def _compute_name(self):
        """Generate display name from barcode and size"""
        for record in self:
            if record.barcode and record.bin_size:
                size_label = dict(record._fields['bin_size'].selection)[record.bin_size]
                record.name = f"{record.barcode} - {size_label}"
            else:
                record.name = record.barcode or 'New Bin'

    @api.depends('bin_size')
    def _compute_bin_type(self):
        """Determine bin type from size selection"""
        for record in self:
            if record.bin_size == '32_console':
                record.bin_type = 'console'
            else:
                record.bin_type = 'bin'

    @api.constrains('barcode')
    def _check_barcode_format(self):
        """Validate barcode format"""
        for record in self:
            if record.barcode:
                # Allow either 10-digit numeric or our sequence formats
                if not (record.barcode.isdigit() and len(record.barcode) == 10) and \
                   not re.match(r'^(BIN23|BIN32|BIN64|BIN96|CON32)\d{5}$', record.barcode):
                    raise ValidationError(
                        _("Barcode must be either 10 digits or follow format: BIN23XXXXX, BIN32XXXXX, BIN64XXXXX, BIN96XXXXX, or CON32XXXXX")
                    )

    @api.model_create_multi
    def create(self, vals_list):
        """Override create to handle barcode generation"""
        for vals in vals_list:
            # If no barcode provided and bin_size is set, generate one
            if not vals.get('barcode') and vals.get('bin_size'):
                vals['barcode'] = self._generate_barcode(vals['bin_size'])
                vals['is_generated'] = True
            elif vals.get('barcode'):
                vals['is_imported'] = True

        return super().create(vals_list)

    def _generate_barcode(self, bin_size):
        """Generate barcode using appropriate sequence"""
        sequence_map = {
            '23_gallon': 'shredding.bin.23gallon',
            '32_gallon': 'shredding.bin.32gallon',
            '32_console': 'shredding.console.32gallon',
            '64_gallon': 'shredding.bin.64gallon',
            '96_gallon': 'shredding.bin.96gallon',
        }

        sequence_code = sequence_map.get(bin_size)
        if not sequence_code:
            raise UserError(_("No sequence defined for bin size: %s", bin_size))

        return self.env['ir.sequence'].next_by_code(sequence_code)

    def action_print_barcode_label(self):
        """Print barcode label for the bin"""
        self.ensure_one()
        return {
            'type': 'ir.actions.report',
            'report_name': 'records_management.shredding_bin_barcode_label',
            'report_type': 'qweb-pdf',
            'res_id': self.id,
        }

    @api.model
    def update_sequences_from_import(self):
        """Update sequences based on imported bins - call after bulk import"""
        sequence_map = {
            '23_gallon': 'shredding.bin.23gallon',
            '32_gallon': 'shredding.bin.32gallon',
            '32_console': 'shredding.console.32gallon',
            '64_gallon': 'shredding.bin.64gallon',
            '96_gallon': 'shredding.bin.96gallon',
        }

        for bin_size, sequence_code in sequence_map.items():
            # Find highest number for this bin size
            prefix_map = {
                '23_gallon': 'BIN23',
                '32_gallon': 'BIN32',
                '32_console': 'CON32',
                '64_gallon': 'BIN64',
                '96_gallon': 'BIN96',
            }

            prefix = prefix_map[bin_size]
            pattern = f"{prefix}%"

            # Search for highest existing number
            bins = self.search([
                ('bin_size', '=', bin_size),
                ('barcode', 'like', pattern),
                ('is_imported', '=', True)
            ], order='barcode desc', limit=1)

            if bins:
                # Extract number from barcode
                barcode = bins[0].barcode
                if barcode.startswith(prefix):
                    try:
                        number_part = barcode[len(prefix):]
                        highest_number = int(number_part)
                        next_number = highest_number + 1

                        # Update sequence
                        sequence = self.env['ir.sequence'].search([('code', '=', sequence_code)])
                        if sequence:
                            sequence.number_next = next_number

                    except ValueError:
                        continue

    # --------------------------------------------------
    # State transition actions (used by form header buttons)
    # --------------------------------------------------
    def action_set_available(self):
        """Mark bin as available (reset from other states)"""
        self.ensure_one()
        if self.state in ('full', 'maintenance', 'retired'):
            if self.state == 'retired':
                raise UserError(_("Cannot set a retired bin back to Available."))
        self.state = 'available'
        self.message_post(body=_("Bin set to Available"))
        return True

    def action_set_full(self):
        """Mark bin as full"""
        self.ensure_one()
        if self.state not in ('in_use', 'available'):
            raise UserError(_("Only bins that are Available or In Use can be marked Full."))
        self.state = 'full'
        self.message_post(body=_("Bin marked Full"))
        return True

    def action_service_complete(self):
        """Service bin and return it to in_use state with updated service dates"""
        self.ensure_one()
        today = fields.Date.context_today(self)
        if self.state != 'full':
            raise UserError(_("Only Full bins can be serviced."))
        self.last_service_date = today
        self.next_service_date = today + relativedelta(days=30)
        self.state = 'in_use'
        self.current_weight = 0.0
        self.fill_percentage = 0.0
        self.message_post(body=_("Service completed; bin returned to In Use."))
        return True
