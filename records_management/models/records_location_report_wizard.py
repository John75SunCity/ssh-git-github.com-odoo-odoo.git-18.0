from odoo import models, fields, api, _
from odoo.exceptions import ValidationError


class RecordsLocationReportWizard(models.Model):
    _name = 'records.location.report.wizard'
    _description = 'Records Location Report Wizard'

    # ============================================================================
    # FIELDS
    # ============================================================================
    name = fields.Char(string="Report Name", default="Location Report")
    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.company)
    user_id = fields.Many2one('res.users', string='Generated By', default=lambda self: self.env.user)
    location_id = fields.Many2one('records.location', string='Location', required=True)
    include_child_locations = fields.Boolean(string='Include Child Locations')
    specific_location_ids = fields.Many2many('records.location', string='Specific Locations')
    report_date = fields.Date(string='Report Date', default=fields.Date.context_today)
    include_date_range = fields.Boolean(string='Use Date Range')
    date_from = fields.Date(string='From Date')
    date_to = fields.Date(string='To Date')
    customer_filter = fields.Selection([
        ('all', 'All Customers'),
        ('specific', 'Specific Customers'),
        ('department', 'By Department')
    ], string='Customer Filter', default='all')
    specific_customer_ids = fields.Many2many('res.partner', string='Specific Customers')
    department_id = fields.Many2one('records.department', string='Department')
    include_container_details = fields.Boolean(string='Include Container Details', default=True)
    include_utilization_stats = fields.Boolean(string='Include Utilization Stats', default=True)
    include_financial_summary = fields.Boolean(string='Include Financial Summary')
    include_charts = fields.Boolean(string='Include Charts')
    output_format = fields.Selection([
        ('pdf', 'PDF'),
        ('excel', 'Excel'),
        ('html', 'Web View'),
        ('both', 'PDF & Excel')
    ], string='Output Format', default='pdf')
    email_report = fields.Boolean(string='Email Report')
    email_recipients = fields.Char(string='Email Recipients')

    location_name = fields.Char(related='location_id.name', string="Location Name", readonly=True)
    total_capacity = fields.Float(compute='_compute_location_summary', string='Total Capacity (CuFt)')
    current_utilization = fields.Float(compute='_compute_location_summary', string='Utilization (%)')
    container_count = fields.Integer(compute='_compute_location_summary', string='Container Count')
    customer_count = fields.Integer(compute='_compute_location_summary', string='Customer Count')

    # ============================================================================
    # COMPUTE METHODS
    # ============================================================================
    @api.depends('location_id', 'include_child_locations')
    def _compute_location_summary(self):
        """Compute location summary statistics"""
        for wizard in self:
            if not wizard.location_id:
                wizard.total_capacity = 0.0
                wizard.current_utilization = 0.0
                wizard.container_count = 0
                wizard.customer_count = 0
                continue

            location_domain = [('id', '=', wizard.location_id.id)]
            if wizard.include_child_locations:
                location_domain = [('id', 'child_of', wizard.location_id.id)]

            locations = self.env['records.location'].search(location_domain)
            containers = self.env['records.container'].search([
                ('location_id', 'in', locations.ids),
                ('active', '=', True)
            ])

            wizard.total_capacity = sum(containers.mapped('cubic_feet'))
            wizard.container_count = len(containers)
            wizard.customer_count = len(set(containers.mapped('partner_id')))

            total_location_capacity = sum(locations.mapped('capacity_cubic_feet'))
            if total_location_capacity > 0:
                wizard.current_utilization = (wizard.total_capacity / total_location_capacity) * 100
            else:
                wizard.current_utilization = 0.0

    # ============================================================================
    # CONSTRAINTS
    # ============================================================================
    @api.constrains('date_from', 'date_to', 'include_date_range')
    def _check_date_range(self):
        """Validate date range configuration"""
        for wizard in self:
            if wizard.include_date_range:
                if not wizard.date_from or not wizard.date_to:
                    raise ValidationError(_('Both From Date and To Date are required for date range analysis.'))
                if wizard.date_from > wizard.date_to:
                    raise ValidationError(_('From Date must be earlier than or equal to To Date.'))

    @api.constrains('customer_filter', 'specific_customer_ids')
    def _check_customers(self):
        """Validate customer selection"""
        for wizard in self:
            if wizard.customer_filter == 'specific' and not wizard.specific_customer_ids:
                raise ValidationError(_('Please select at least one customer for the specific customer filter.'))

    @api.constrains('email_report', 'email_recipients')
    def _check_email(self):
        """Validate email configuration"""
        for wizard in self:
            if wizard.email_report and not wizard.email_recipients:
                raise ValidationError(_('Email recipients are required when "Email Report" is enabled.'))

    # ============================================================================
    # ONCHANGE METHODS
    # ============================================================================
    @api.onchange('customer_filter')
    def _onchange_customer_filter(self):
        """Clear customer selections when filter changes"""
        if self.customer_filter != 'specific':
            self.specific_customer_ids = [(5, 0, 0)]
        if self.customer_filter != 'department':
            self.department_id = False

    # ============================================================================
    # ACTION METHODS
    # ============================================================================
    def action_generate_report(self):
        """Generate and return the location report"""
        self.ensure_one()
        self._validate_report_parameters()

        report_data = self._prepare_report_data()

        if self.output_format == 'pdf':
            return self._generate_pdf_report(report_data)
        elif self.output_format == 'excel':
            return self._generate_excel_report(report_data)
        elif self.output_format == 'html':
            return self._generate_html_report(report_data)
        else:  # both
            pdf_action = self._generate_pdf_report(report_data)
            excel_action = self._generate_excel_report(report_data)

            if self.email_report:
                # This part needs a more robust implementation to attach multiple reports:
                # Ideally, both the PDF and Excel files should be generated, saved as attachments (using ir.attachment),
                # and then attached to the outgoing email sent to the recipients.
                # This requires generating the files, creating ir.attachment records for each,
                # and passing their IDs to the mail template or mail.compose.message.
                # For now, we can send the PDF as an example.
                self._email_reports([pdf_action, excel_action])

            # Returning PDF by default when 'both' is selected for direct download
            return pdf_action

    def _validate_report_parameters(self):
        """Validate all report parameters before generation"""
        self.ensure_one()
        # Constraints handle most validations, this is for any additional checks
        if not self.location_id:
            raise ValidationError(_('A location is required to generate a report.'))

    def _prepare_report_data(self):
        """Prepare comprehensive report data for the report templates"""
        self.ensure_one()
        return {
            'wizard': self.read()[0],
            'location_data': self._get_location_data(),
            'container_data': self._get_container_data() if self.include_container_details else [],
            'customer_data': self._get_customer_data(),
            'utilization_data': self._get_utilization_data() if self.include_utilization_stats else {},
            'financial_data': self._get_financial_data() if self.include_financial_summary else {},
            'generated_date': fields.Datetime.now(),
            'report_parameters': self._get_report_parameters(),
        }

    def _get_location_data(self):
        """Get location-specific data"""
        location_domain = [('id', '=', self.location_id.id)]
        if self.include_child_locations:
            location_domain = [('parent_path', '=like', f"{self.location_id.parent_path}%")]

        locations = self.env['records.location'].search(location_domain)
        return [
            {
                'id': loc.id,
                'name': loc.name,
                'capacity': loc.capacity_cubic_feet or 0.0,
                'current_usage': sum(self.env['records.container'].search([
                    ('location_id', '=', loc.id),
                    ('active', '=', True)
                ]).mapped('cubic_feet')),
                'address': loc.address or '',
                'phone': loc.phone or '',
                'manager': loc.manager_id.name if loc.manager_id else '',
            }
            for loc in locations
        ]

    def _get_container_data(self):
        """Get container inventory data"""
        location_domain = [('id', '=', self.location_id.id)]
        if self.include_child_locations:
            location_domain = [('id', 'child_of', self.location_id.id)]

        locations = self.env['records.location'].search(location_domain)
        containers = self.env['records.container'].search([
            ('location_id', 'in', locations.ids),
            ('active', '=', True)
        ])

        return [
            {
                'id': container.id,
                'name': container.name,
                'customer': container.partner_id.name if container.partner_id else '',
                'location': container.location_id.name if container.location_id else '',
                'volume': container.cubic_feet or 0.0,
                'status': container.state or 'unknown',
                'created_date': container.create_date.strftime('%Y-%m-%d') if container.create_date else '',
            }
            for container in containers
        ]

    def _get_customer_data(self):
        """Get customer distribution data"""
        location_domain = [('id', '=', self.location_id.id)]
        if self.include_child_locations:
            location_domain = [('id', 'child_of', self.location_id.id)]

        locations = self.env['records.location'].search(location_domain)
        containers = self.env['records.container'].search([
            ('location_id', 'in', locations.ids),
            ('active', '=', True)
        ])

        customer_data = {}
        for container in containers:
            customer = container.partner_id
            if customer:
                if customer.id not in customer_data:
                    customer_data[customer.id] = {
                        'name': customer.name,
                        'container_count': 0,
                        'total_volume': 0.0,
                    }
                customer_data[customer.id]['container_count'] += 1
                customer_data[customer.id]['total_volume'] += container.cubic_feet or 0.0

        return list(customer_data.values())

    def _get_utilization_data(self):
        """Get utilization statistics"""
        location_domain = [('id', '=', self.location_id.id)]
        if self.include_child_locations:
            location_domain = [('id', 'child_of', self.location_id.id)]

        locations = self.env['records.location'].search(location_domain)
        total_capacity = sum(locations.mapped('capacity_cubic_feet'))

        containers = self.env['records.container'].search([
            ('location_id', 'in', locations.ids),
            ('active', '=', True)
        ])
        used_capacity = sum(containers.mapped('cubic_feet'))

        return {
            'total_capacity': total_capacity,
            'used_capacity': used_capacity,
            'available_capacity': total_capacity - used_capacity,
            'utilization_percentage': (used_capacity / total_capacity * 100) if total_capacity > 0 else 0,
            'container_count': len(containers),
            'customer_count': len(set(containers.mapped('partner_id'))),
        }

    def _get_financial_data(self):
        """Get financial summary data by calculating revenue from containers."""
        self.ensure_one()

        location_domain = [('id', '=', self.location_id.id)]
        if self.include_child_locations:
            location_domain = [('id', 'child_of', self.location_id.id)]

        locations = self.env['records.location'].search(location_domain)
        containers = self.env['records.container'].search([
            ('location_id', 'in', locations.ids),
            ('active', '=', True)
        ])

        total_monthly_revenue = 0.0
        for container in containers:
            total_monthly_revenue += container.billing_rate

        return {
            'total_monthly_revenue': total_monthly_revenue,
            'total_quarterly_revenue': total_monthly_revenue * 3,
            'total_annual_revenue': total_monthly_revenue * 12,
            'note': _("Calculated based on the 'billing_rate' field of each container.")
        }

    def _get_report_parameters(self):
        """Get formatted report parameters for display in the report"""
        return {
            'report_name': self.name,
            'report_date': self.report_date.strftime('%Y-%m-%d') if self.report_date else '',
            'location': self.location_id.display_name,
            'customer_filter': dict(self._fields['customer_filter'].selection).get(self.customer_filter),
            'include_children': self.include_child_locations,
            'output_format': dict(self._fields['output_format'].selection).get(self.output_format),
        }

    def _generate_pdf_report(self, report_data):
        """Generate PDF report"""
        return self.env.ref('records_management.action_report_location').report_action(self, data=report_data)

    def _generate_excel_report(self, report_data):
        """Generate Excel report"""
        # Placeholder for Excel report generation
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Feature Not Available'),
                'message': _('Excel report generation feature is coming soon.'),
                'sticky': False,
                'type': 'info',
            }
        }

    def _generate_html_report(self, report_data):
        """Generate HTML report"""
        # Placeholder for HTML/web view report generation
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Feature Not Available'),
                'message': _('HTML web view report generation feature is coming soon.'),
                'sticky': False,
                'type': 'info',
            }
        }

    def _email_reports(self, reports):
        """Email reports to specified recipients, attaching the provided report files"""
        if not self.email_recipients or not reports:
            return False

        # Prepare attachments (expects reports as list of dicts with 'name' and 'data' keys)
        attachment_ids = []
        for report in reports:
            if isinstance(report, dict) and report.get('name') and report.get('data'):
                attachment = self.env['ir.attachment'].create({
                    'name': report['name'],
                    'datas': report['data'],
                    'res_model': self._name,
                    'res_id': self.id,
                    'type': 'binary',
                })
                attachment_ids.append(attachment.id)

        mail_template = self.env.ref('records_management.email_template_location_report', raise_if_not_found=False)
        if mail_template:
            mail_template.with_context(
                email_to=self.email_recipients,
                attachment_ids=attachment_ids
            ).send_mail(self.id, force_send=True)
        return True

