#!/usr/bin/env python3
"""Generate dependency-aware models/__init__.py import ordering.

Scans records_management/models/*.py extracting:
  - _name = 'model.name'
  - _inherit = 'model.name' or list/tuple including names
Builds a directed graph: base model file -> inheriting file(s).
Emits import lines ensuring each file defining a model is imported
before any file that inherits/extends it (topological order) while
preserving deterministic alphabetical fallback for unrelated groups.

Usage:
  python3 development-tools/generate_models_init.py --write   # overwrite models/__init__.py
  python3 development-tools/generate_models_init.py --print   # print proposed content

This does NOT modify files outside models/. Non-Python artifacts ignored.
Safeguards:
  - Ignores files that already imported (dedupe)
  - Falls back to simple alpha order if cycle detected, logging a warning
  - Keeps explicitly pinned priority list (CRITICAL_FIRST) at the top

Extend CRITICAL_FIRST if you discover additional early-load bases.
"""
from __future__ import annotations
import argparse
import os
import re
import sys
from pathlib import Path
from collections import defaultdict, deque

MODULE_ROOT = Path(__file__).resolve().parent.parent / 'records_management'
MODELS_DIR = MODULE_ROOT / 'models'
INIT_FILE = MODELS_DIR / '__init__.py'

MODEL_NAME_RE = re.compile(r"^\s*_name\s*=\s*['\"]([a-zA-Z0-9_.]+)['\"]", re.MULTILINE)
INHERIT_SINGLE_RE = re.compile(r"^\s*_inherit\s*=\s*['\"]([a-zA-Z0-9_.]+)['\"]", re.MULTILINE)
INHERIT_COLLECTION_RE = re.compile(r"^\s*_inherit\s*=\s*([\[]|\()[^\n]+", re.MULTILINE)
STRING_LITERAL_RE = re.compile(r"['\"]([a-zA-Z0-9_.]+)['\"]")

# Files that must appear early regardless of graph (base definitions with many extensions)
CRITICAL_FIRST = [
    'records_billing_config.py',  # prevents missing model inheritance
]

EXCLUDE_FILES = {"__init__.py", "__pycache__"}


def discover_files():
    for f in MODELS_DIR.glob('*.py'):
        if f.name in EXCLUDE_FILES:
            continue
        yield f


def parse_model_metadata(path: Path):
    text = path.read_text(encoding='utf-8', errors='ignore')
    names = MODEL_NAME_RE.findall(text)  # usually one per file (enforce policy)
    inherits = []
    single = INHERIT_SINGLE_RE.findall(text)
    if single:
        inherits.extend(single)
    else:
        coll = INHERIT_COLLECTION_RE.findall(text)
        if coll:
            # extract all string literals in the first line of the collection
            inherits.extend(STRING_LITERAL_RE.findall(coll[0]))
    return names, inherits


def build_graph():
    file_by_model = {}
    inherits_by_file = {}

    for f in discover_files():
        model_names, inherit_models = parse_model_metadata(f)
        for mn in model_names:
            file_by_model[mn] = f.name
        inherits_by_file[f.name] = inherit_models

    graph = defaultdict(set)  # file -> set(files that depend on it)
    indegree = defaultdict(int)

    # initialize indegree for all files
    for f in inherits_by_file:
        indegree[f] = 0

    for file_name, inherit_models in inherits_by_file.items():
        for parent_model in inherit_models:
            parent_file = file_by_model.get(parent_model)
            if parent_file and parent_file != file_name:
                if file_name not in graph[parent_file]:
                    graph[parent_file].add(file_name)
                    indegree[file_name] += 1
    return graph, indegree, set(inherits_by_file.keys())


def topo_sort():
    graph, indegree, all_files = build_graph()

    queue = deque()
    for f in sorted(all_files):
        if indegree[f] == 0:
            queue.append(f)

    ordered = []
    while queue:
        cur = queue.popleft()
        ordered.append(cur)
        for nxt in sorted(graph.get(cur, [])):
            indegree[nxt] -= 1
            if indegree[nxt] == 0:
                queue.append(nxt)

    if len(ordered) != len(all_files):
        cycle_files = all_files - set(ordered)
        sys.stderr.write(f"[WARN] Cycle detected among: {', '.join(sorted(cycle_files))}\n")
        # Append remaining in deterministic order
        ordered.extend(sorted(cycle_files))

    # Move critical-first files to front preserving their relative order
    critical = [f for f in CRITICAL_FIRST if f in ordered]
    remaining = [f for f in ordered if f not in critical]
    return critical + remaining


def generate_init_lines():
    ordered_files = topo_sort()
    lines = [
        "# Auto-generated by development-tools/generate_models_init.py",
        "# DO NOT manually alphabetize if it breaks inheritance; regenerate instead.",
        "# Critical bases are placed first, then dependency-resolved order.",
        "",
    ]
    for fname in ordered_files:
        module_name = fname[:-3]  # strip .py
        lines.append(f"from . import {module_name}")
    lines.append("")
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--write', action='store_true', help='Overwrite models/__init__.py')
    parser.add_argument('--print', action='store_true', help='Print proposed content')
    args = parser.parse_args()

    content = generate_init_lines()
    if args.print or not args.write:
        print(content)
    if args.write:
        INIT_FILE.write_text(content, encoding='utf-8')
        print(f"[OK] Wrote dependency-aware init to {INIT_FILE}")

if __name__ == '__main__':
    main()
